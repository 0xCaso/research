\section{Introduction}\label{sec:intro}
Internet was originally designed as a collection of interconnected decentralised entities which is noticeable by the design of its early protocols such as TCP/IP and SMTP. However, its commercialisation has led to the centralisation of most of the applications present on the web. We refer not to the centralisation of physical infrastructure, which is often economically efficient, but rather to the logical centralisation of the ability to deploy, take down, alter, and change the rules of the application. Two prominent examples are giant corporations like Google and Facebook: while they do have run/maintain servers all around the world, these are ultimately controlled by a single legal entity.

Giving a central entity control over a system poses several risks as much for the users as for the application developers. For example, the central entity can stop the service at any moment, can sell users' data to third parties depending on the jurisdictions they provide service to, and manipulate how the service is working without the users consent.

With all this current development around corporative interests related to personal data and applications ownership, there is a current countermovement and a growing need for a better security, freedom and fairness for the users on the web, and with this - for more decentralised applications, where no single entity can control the whole system.
    
The process of decentralisation is not new. It has been used in a number of areas of the development of web and other systems, starting with the free software movement in the 1970s. Today, we can see decentralisation practices in different areas of the online development such as as games \cite{}, storage \cite{}, decentralised exchanges \cite{}, auctions\cite{}, and financial systems \cite{}.

One of the fundamental challenges of developing a decentralised application is storing and communicating the current state of the application. That is because there is no central entity who follows the current state or can decide what the current valid state is if there is any doubt. Blockchains are technologies which are proposed to address this problem.

In order to make the decentralised web usable for end-users, often separate blockchain applications need to interact, otherwise, each will become isolated and not adopted by as many users, and the overall functionality of the system will be insufficient to compete with the centralised web. However, to interact with different chains, one needs to build an interoperability mechanism, which introduces challenges. Many of these challenges which are missing in the centralised model arise because of the fundamental differences in the trust model between the two paradigms. The simple authentication mechanisms such as OAuth \cite{hardt2012oauth} can not easily be adapted to the decentralised web where there is no central entity guarding the secret key. Furthermore, it is not straight forward for decentralised entities to establish trust between each other when they use different mechanisms to ensure the security of their respective systems. For example, Bitcoin\cite{} and Ethereum\cite{} are proof-of-work (PoW) blockchains where decentralisation is carried out by introducing puzzles that need a large amount of computing power to solve. Their security relies on whether this amount of processing power exceeds the amount of processing power any single entity would possibly have. An alternative to PoW is a proof-of-stake (PoS) system, where the entities that control the system have to lock a large amount of funds and would be punished if they misbehave in any way. The security relies on the fact that the total amount of locked funds exceeds the budget any the adversary is able to invest in the attack. These technical differences present difficulties for one blockchain to be able to trust another.

Currently, there have been hundreds of chains implemented in the wild for various functions and non-compatible underlying technology. Most of these systems have different properties they aim to achieve and a certain security threshold that they set up. Having multiple security setups causes a substantial split in the security all these systems can provide. In this paper, we introduce Polkadot, a multi-chain system that aims at gathering the security power of all these chains to have a shared security system. Polkadot utilises a central chain called the \emph{Relay Chain} which communicates with multiple heterogeneous and independent sharded chains called \emph{Parachains} (portmanteau of parallel chains). The Relay chain is responsible to provide shared security for all parachains. Another goal of Polkadot is providing trust-free interchain transactability among parachains. By featuring these points Polkadot is  addressing the interoperability and scalablility shortcomings of blockchains technologies.

This paper is organised as follows. We first review preliminary information such as description of roles of Polkadot's participants and our adversary model. We then continue to review all sub-protocols, aka components, of Polkadot and low-level cryptographic and networking primitives. We conclude with a summary of the described components and explain what they try to achieve \ref{sec:summary}. 

%\syed{Polkadot enables the parachains to communicate together and have shared security.}{So we do not need to repeat this}

%\handan{Furthermore, scalability is another challenge for blockchains to make them comparable with centralised services in functionality.}{it may be better to talk about it when we mention challenges of interoperability}\syed{}{I agree with Handan, specially that scalability is partially related to interoperability, for example, the reason that Ethereum tried to be generic computer is because it wanted to have all Dapps lives inside so they can communicate efficiently which resulted in scalability problem. But we also can talk much more about scalability }
%Polkadot's hierarchical structure addresses this challenge.


%The paper is organised as follows. In Section~\ref{sec:properties} we review the properties that Polkadot is aiming for and Section~\ref{sec:preliminiary} examines the structural components and roles that we defined for Polkadot.
%Section~\ref{sec:components} presents all the underlying components including protocols and primitives that have been designed for Polkadot as well as a note about incentives and economics.

