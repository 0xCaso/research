\subsection{Consensus}\label{sec:consensus}

In this section, we explain the hybrid consensus protocol of Polkadot which consists of BABE: a block production mechanism of the relay chain that provides probabilistic finality and GRANDPA which provides provable, deterministic finality and works independently from BABE.  Informally, probabilistic finality implies that after certain time \eray{passed}{passes}, a block in the relay chain will be finalized with very high probability (close to 1) and deterministic finality implies a finalized block stays final forever. \eray{Provable}{Furthermore, provable} finality means that \eray{furthermore,}{-remove-} we can prove to parties not actively involved in the consensus that a block is final.

We need provable finality to \eray{makes}{make} bridges to chains outside Polkadot easier and for that we need a Byzantine agreement \eray{tyoe}{-comment: ?-} of consensus. \eray{But}{However,} the validity and availability scheme \eray{also}{-remove-} may also require us to revert blocks, which would mean that getting Byzantine agreement on every block, as in Tendermint or Algorand, would not be suitable. However, this should happen rarely as a lot of \eray{stake}{stakes} will be slashed when we do this. As a result, we want a scheme that generates blocks and optimistically executes them, but \eray{}{it} may take some time to finalise them. \eray{The way XCMP works, mean that message passing speed is constrained by block time, but not by finality time so if we delay finality, but in the end do not revert, then message passing is fast.}{-comment:??-} 
\eray{Even the speed at \eray{whoch}{which} we finalise blocks may \eray{be variable}{vary} - if we do not recieve reports of invalidity and unavailability then we can finalise fast, but if we do then we may need to delay finality while we execute more involved checks.}{-comment:?? This paragraph needs to be rewritten as it is not clear what's meant here.-}

As a result of these requirements, we have chosen to seperate the mechanisms for block production and finalising blocks as much as possible. In the next \eray{twos ections}{two sections}, we describe the protocols BABE and GRANDPA that \eray{do each of these}{-comment:??-}.

%In our consensus protocols, we assume that a message sent by a validator arrives to other validators at most $\D$ times later where $\D$ is an unknown parameter. So, validators are in a partially synchronous network that guarantees  eventual delivery.
\input{babe.tex}


\subsubsection{GRANDPA} \label{sec:grandpa}
\begin{figure}[h!]
  \centering
  \includegraphics[width=0.4\textwidth]{images/Grandpa.jpg}
  \caption{GRANDPA votes and how they are aggregated. \eray{}{-comment:The figure and fonts are too small, make it bigger-}}
    \label{fig:grandpa}
\end{figure}

As mentioned above, we want a finalisation mechanism that is flexible and seperated from block production, which is achieved by GRANDPA. The only modofication to BABE required for it to work with GRANDPA is to change the fork-choice rule: instead of building on the longest chain, a validitor producing a block should build on the longest chain including all blocks that it sees as finalised. GRANDPA can work with many different block production mechanisms and it should be possible to switch out BABE with another.

\eray{}{-comment:empty space again.-}