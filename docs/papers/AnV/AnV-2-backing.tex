
\section{Backing}
\label{sec:backing}

We now describe the subprotocols that provide the preliminary financial backing checks from parachain validators and that ensure availability for our later approval validity checks.


We now describe and instantiate our {\em availability and validity protocol} that provides efficient sharding.  It consists of 
\begin{itemize}
\item a parachain phase that prepares the candidate block and performs preliminary backing validity checks,
\item a relay chain submission phase that distributes candidate parachain blocks and produces relay chain blocks,
\item availability and unavailability subprotocols that enforce availability in GRANDPA and BABE respectively,
\item fuller approval validity checks for GRANDPA,
\item objection procedures for fishermen, and
\item invokation of a Byzantine fault tolerant ``finality gadget'' that gives us finality.
\end{itemize}


% TODO: Anything more worth saying here?  Maybe extract from:  The parachain phase is executed between collators and parachain validators. In the end of this phase, the parachain validators validate the block and provide its erasure code pieces to the validators. Then, the relay chain phase begins. If the parachain phase is executed correctly, then the relay chain phase includes extra validation of a parachain block, adding the block header to the relay chain and finalizing that relay chain block. Otherwise, unavailability protocol is run between validators. The details are as follows: 


\subsection{Parachain phase} 
\label{sec:parachain}

We first describe the protocol by which collators of a parachain $\para$ submit a candidate block to the parachain validators $\vals_\para$ assigned to $\para$.

\smallskip
\paragraph{Collator subphase:} 

Initially, some {\bf collator} $C$ of a parachain $\para$ must propose some candidate block $B$ for $\para$.  We let $B'$ denotes the parent of $B$.  As above, let $\rin$ and $\rout$ denote state root before and after executing $B$.  

In practice, we want shared security, among other reasons so that parachains can communicate easily.  As such, $B$ should reference some relay chain block(s) $R^0_B$ that distinguish any state $\rho$ maintains on the relay chain, such as the incoming messages accumulated for $\rho$ to be processed by $B$.  We let $q$ denote the Merkle root of this state $\rho$ maintains on the relay chain in $R^0_B$.  

In principle, $B$ could reference extra data $M$ determined by $R^0_B$ and supplied by the relay chain, but not actually included inside the relay chain state.  We envision $M = \emptyset$ for the foreseeable future however. 

First, $C$ constructs the witness data $\pi$ by evaluating the block with $\prove_{\hat{\para}}(B,M)$, so they can build the {\em candidate proof-of-validity blob} $\blobB = (B,\pi)$, and also obtain the block metadata $(\para.\mathsf{id},H(B'),H(R^0_B),\rin,\rout,q,\ldots)$.

As $\prove$ is a randomized algorithm, $C$ must next reevaluate the block with $\verify_{\hat{\para}}(\blobB,M)$.  We shall assume verification succeeds, but if this verification fails then $C$ reports invalid parachain code for $\para$, and discards $B$ or possibly shuts down.  Assuming no errors, $C$ sends the candidate blob $\blobB$ to the corresponding parachain validators $\vals_\para$, along with any block metadata $(\para.\mathsf{id},H(B'),H(R^0_B),\rin,\rout,q,\ldots)$. 

\smallskip
\paragraph{Parachain validator subphase:}

We shall expect the parachain validator $V$ that processes candidate blob $\blobB$ to update $\blobB$'s associated metadata to reference the most recent relay chain block $R^1_B > R^0_B$, so long as $R^1_B$ still contains the same state root $q$ for $\rho$,
i.e.\ $(H(B'),\rin,\rout,H(R^1_B),$\vect{R^1_B q}$,\ldots)$.

Next each {\em parachain validator} $V \in \vals_\para$ should checks the validity of the block by evaluating the block with $\verify_\para(\blobB,M)$, which we term the {\em preliminary backing validity checks}.  If verification succeeds, then $V$ gossips $\blobB$ among the parachain validators $\vals_\para$ after checking $\blobB$ itself, and we continue below.

If however verification fails, the parachain validator rejects the candidate $\blobB$ and report it as invalid.  We abandon $B$ if no validators sign it, but invalidity claims cannot necessarily result in penalties for either $\para$ or $C$.  

At any time, if any two validators disagree about a parachain block's validity then all validators shall check the block.  In this case, we accumulate votes until $f+1$ claim validity or invalidity, and then slash the loosing side.  We cannot slash if neither side reaches $f+1$, but we still declare the block invalid in that case.  We expect governance to identify software faults and manually revert slashes they cause, but governance can also manually institute slashes in this second case, or manually slash $\para$ for offenses like malicious code or improper non-determinism. 


\subsection{Relay chain authorship} % Relay chain phase I: Block production 
\label{sec:backing}

We next describe the protocol by which the parachain validators $\vals_\para$ assigned to $\para$ announce parachain candidates to the full validator set $V$ for announcement in a candidate backed transaction in a relay chain block.

\smallskip
\paragraph{Parachain validator subphase:}

We require at least $\primarychecks$ of the parachain validators $\vals_\para$ sign preliminary backing validity checks for $B$ before continuing, so we assume this going forward.

Now any {\em parachain validator} $V \in \vals_\para$ runs $\encode_{f+1,\nvals}(\blobB)$ to obtain the {\em unauthenticated pieces} list $\prepieces_B$ of $\nvals$ distinct erasure code symbols aka pieces for $\blobB$.  $V$ computes a Merkle root $\merkleroot_B$ for the Merkle tree with leaves $\prepieces_B$.  

We next define an {\em abridged candidate candidate receipt} that consists of 
\begin{itemize}
\item the parachain id $\para.\mathsf{id}$,
\item the relay chain parent(s) hashes $H(R^0_B)$, 
\item the Merkle root, $\merkleroot_B$,
\item some some block header that contains $H(B)$, $H(M)$, and references the parachain parent $B'$,
\item state commitments $\rin,\rout,q$, and
\item the collator's id $C.\mathsf{id}$ and signature $C.\mathsf{sig})$. 
\end{itemize}
We caution the parachain validator sets $\vals_\para$ rotate, so an abridged candidate candidate receipt must uniquely identify $\vals_\para$.  We achieve this by using $H(R^0_B)$ to determine the assignment $\para.\mathsf{id} \mapsto \vals_\para$, which requires that $R^0_B$ be quite recent.  We could store $\receipt_{B'}$ in the parachain state if required. 

We also define an {\em (inner) candidate receipt} $\receipt_B$ that consists of this abridged candidate candidate receipt and specific data computable by relay chain validators.  Now $V$ creates a signature $\sigma$ for the candidate receipt and constructs the {\em attested candidate receipt} $\receipt_{B,S} := (\receipt_B,S)$ for $B$ by attaching an initial attestation set $S = \{ (V,\sigma) \}$.
% TODO: Improve explicit state root commitments maybe?
% Also Joe asks if we should talk about parachain block headers
% Improve if handling?
% Any more detail about prioritization of candidates?
% Anything else?

We gossip abridged candidate receipts, along with their attestations signature sets $S$, among the parachain validators $\vals_\para$, so they obtain the full attested candidate receipts $\receipt_{B,S}$.  We define more roles for attestations $(V',\sigma') \in S$ below, but we say $(V',\sigma')$ is a {\em backing attestation} for $V \in \vals_\para$.
%
Any parachain validators $V' \in \vals_\para$ who receives a $\receipt_{B,S}$ downloads $\blobB$ from $C$ or another validator who attests in $S$.  After receiving $\blobB$, then they gossip with their own backing attestation $(V',\sigma')$ as $S := S \cup \{ (V',\sigma') \}$

In gossiping $\receipt_{B,S}$, we further aggregate these attestation signature sets $S$.\footnote{We envision $\vals_\para$ being small enough that BLS signatures do not improve verification time over Schnorr signatures, although BLS might reduce the candidate receipt's signature from 640 bytes down to 50 bytes.}  
If $S$ accumulates at least $\primarychecks$ backing attestations from distinct validators in $\vals_\rho$, then we publish $\receipt_{B,S}$ for relay chain block producers using relay chain gossip (mempool).
If however $S$ remains too small too long, then validators in $\vals \setminus \vals_\rho$ ignore $\receipt_{B,S}$.
We think $\primarychecks = {1\over2} \npvals$ gives a reasonable choice, but our security analysis only requires that enough stake back $B$, so even $\primarychecks = 1$ suffices provided each backing validator possesses enough stake.

We archive $B$ if another conflicting blocks gets finalised by GRANDPA, eventually deleting it.  We archive but probably do not delete $B$ if GRANDPA is stalled, probably even when the fork choice rule favours other forks. 

\smallskip
\paragraph{Relay chain block producer:}

We announce attested candidate receipts $\receipt_{B,S}$ in two relay chain transaction types.  We first provide a {\em candidate backed transaction} that merely demonstrates enough backing attestations $\receipt_{B,S}$ so that availability work begins, as described below in \S\ref{sec:availability}.  We then later post a {\em candidate available transaction} that begins the approval checks and attestations, as described below in \S\ref{sec:approval}.

\smallskip

We consider a {\bf relay chain block producer} $U \in \vals$ has an upcoming relay chain block production slot in which $U$ shall make a relay chain block $R$.  If the following two condition hold, then $U$ considers inclusion in $R$ a {\em candidate backed transaction} announcing our attested candidate receipt $\receipt_{B,S}$.
\begin{itemize}
%
\item $\receipt_{B,S}$ has at least $\primarychecks$ backing attestations in $S$.  We note that $U$ should continues collecting the signatures $S$ on $\receipt_{B,S}$ while waiting its block production slot.\footnote{See \href{http://research.web3.foundation/en/latest/polkadot/BABE/Babe/}{BABE} for more details on block production.}
% TODO: Any specific comments on relay chain block headers $\bh$
%
\item Some ancestor $R' \le R$ contains a candidate available transaction with candidate receipts $\receipt_{B',S'}$ for the parent parachain block $B'$ of our candidate $\receipt_{B,S}$
%
\item If another relay chain block $R''$ between $R$ and $R'$ that includes another candidate backed transaction for another $\receipt_{B'',S''}$ then no relay chain block between $R''$ and $R$ contains a candidate available transaction for $\receipt_{B'',S''}$, and some expiration condition applies to $\receipt_{B'',S''}$.  
We leave the expiration conditions to future work, but one example would be $R''$ being 64 blocks before $R$.
%
\end{itemize}
Importantly, $U$ need not validate $B$ itself unless $U \in \vals_\para$.


\smallskip
\paragraph{Role churn:}

We again caution that parachain validator assignments $\vals_\rho$ change somewhat frequently and worse our entire validator set $\vals$ changes periodically too.  We place no future demands upon the collators or relay chain block producer after block creation, so their churn creates no problems.  We shall require that backing attesters in $\vals_\rho$ continue to share $\blobB$, both in its entirety and in smaller pieces described next in \S\ref{sec:availability}, which makes churn problematic.  

As noted above, any candidate receipt $\receipt_{B,S}$ uniquely identifies $\vals_\para$ because it includes $\para.\mathsf{id}$ while the recent relay chain parent $H(R^0_B)$ determines the assignment $\para.\mathsf{id} \mapsto \vals_\para$.
It addresses churn in $\vals$ too because the nothing-at-stake problem imposes a long unbonding period, during which time we may continue rewarding outgoing validators for work, even if they lie in the old $\vals_\para$ but not the new $\vals$.   
% TODO: Cite unbonding period?
An implementations should end (micro)epoch gently with heuristics that permit gossip somewhat after the (micro)epoch and even last minute backing attestations by validators in $\vals_\para \setminus S$.

As an aside, one could consider backing attesters $\vals_\para$ coming form outside the validator set $\vals$, but doing so more requires more complex staking logic. 

