\section{Introduction}

The property of proportional representation in approval-based committee elections, discussed in the literature of computational social choice for a long time, is typically understood as guaranteeing that small minorities within the electorate are not \emph{underrepresented} by the winning committee. This is certainly an imperative in any fair election process as it ensures that all voices are heard and all communities are satisfied and engaged. 
In this paper, we complement this notion by formalizing the opposite goal of preventing the \emph{overrepresentation} of any minority. We consider this goal to be a matter of security, and analyze a scenario where a large adversarial minority may use strategic voting to attempt to gain overrepresentation, in order to capture the governance body or interfere with its correct functioning. 

To resist such an attack, we define an optimization problem where --in simple terms-- the amount of votes backing any seat in the committee is maximized. The objective function ensures that an individual's vote is not double-counted across multiple seats, which neutralizes the effect of strategic voting to a large extent. In this work we retrieve this objective function from first principles and provide a thorough analysis of its theoretical complexity. We also establish its connection to relevant axioms of proportional representation in the literature, and compare how popular election rules fare with respect to it. Finally, we present a new efficient election rule that provides theoretical guarantees in the prevention of both underrepresentation and overrepresentation, thus ensuring both proportionality and security.

Our work is motivated by an application on public, permissionless blockchain networks. These networks are equipped with computational and economic capabilities and have no central authority nor single point of failure, which provides them with unprecedented levels of decentralization and resistance to attacks, and for the first time removes the need for trusted intermediaries in peer-to-peer value transfer across the world. Recent years have seen an explosion of blockchain-based applications in finance, commerce, corporations, art and gaming. Rather than controlling the identity and correct execution of its nodes, a blockchain network freely allows nodes to join or leave the network pseudonymously, and adds enough redundancy to resist the erroneous execution of any one of them. Nodes that participate in the blockchain consensus protocol are denoted as \emph{validators}, and the correct functioning of the network is guaranteed as long as a supermajority of validators execute correctly.

Yet, the advantages of a blockchain architecture come at the cost of hard computational limitations. For every new block of transactions, all validators around the globe need to perform the same computations locally, and the network must wait for all of them to finish and agree on the results before processing the next block. Furthermore, a robust design must account for computationally weak validators, such as consumer-grade computers, as imposing high performance requirements would lead to centralization, so the per-block computational load must remain conservatively low. Because of this, the Bitcoin network for instance can process a maximum of 7 transactions per second. 

As a consequence, only the simplest and most efficient of protocols admit a straightforward implementation over a blockchain network. This represents a considerable hindrance for the use of committee election rules, in particular those sophisticated enough to provide guarantees on proportional representation. As a case in point, the $\MMS$ rule provides very strong guarantees on proportionality and security, as we establish in this paper, but its slow runtime makes it unsuitable for implementation. On the other hand, the EOS network implements the multiwinner Approval Voting rule to elect its validators, a rule that is highly efficient yet known to perform very poorly in terms of proportional representation. The use of this rule, in all likelihood selected due to performance considerations, has led to user dissatisfaction and claims of excessive centralization of the EOS network.%
\footnote{For an opinion piece on the topic, see the blogpost ``EOS voting structure encourages centralization'' by Priyeshu Garg at \url{https://cryptoslate.com/eos-voting-structure-encourages-centralization/}.}
The issue of implementability of election rules has become ever more relevant in recent time more and more blockchain projects abandon the notion of immutable code and in favor of designs that facilitate future code upgrades via governance processes. Many projects even embrace complex governance structures in which users can vote on committees and referenda, launch their own candidacies, raise proposals, form commissions, etc. 

Several solutions have been proposed and implemented for scaling up the computational capabilities of blockchain networks, such as sharded architectures and layer-2 solutions. Of relevance to our work is the use of \emph{verifiable computing schemes}. Such a scheme offloads a heavy task to one or more \emph{off-chain workers}, that is, entities that are logically separated from the network and may process the task on high-performance machines and/or with relaxed time frames as their operations do not interfere with regular block production. Once the task is completed and the output is loaded back onto the network, its correctness is verified by the validators. This is a sensible scheme for any task that admits a \emph{verification process} on its output that guarantees correctness, even when the task is performed privately by an untrusted party that only communicates such output, provided that this verification process is much more efficient than performing the task from scratch. A main contribution of this paper is showing that, from the winning committee that is output by our proposed election rule, along with the original input instance, one can verify the guarantees on proportionality and security in only linear time. Hence, our election rule can be successfully implemented as a verifiable computing scheme, and in fact it has been implemented as such in the Polkadot and Kusama networks, where it is applied in their validator election protocols; we include details of this implementation in one of our sections. Therefore, the present work constitutes a first effort in the study of verifiability within the election theory community. Naturally, giving anyone the power to efficiently verify the correctness of the results in an election process is a valuable goal in itself, beyond any concerns of implementation over blockchain networks.

\vspace{5mm}
\textbf{Problem definition and the validator election protocol.}
Let us now introduce our motivating application, out of which the theoretical goals and optimization problem that we pursue in this paper will emerge naturally. 
Many blockchain networks launched in recently years substitute the highly inefficient Proof-of-Work (PoW) component of Nakamoto's consensus protocol~\cite{nakamoto2019bitcoin} with Proof-of-Stake (PoS), in which validators participate in block production with a frequency proportional to their holdings of the native token, as opposed to their computational power. 
While a pure PoS system allows any willing token holder to participate directly as a validator, most projects place a hard bound $k$ on the number of validators that can be active at any given moment. Arguments for setting such a bound are that the increase in operational costs and communication complexity eventually outmatches the marginal increase in benefits stemming from decentralization as $k$ grows, and that it is typically observed in networks (both PoW- and PoS-based) with a large number of validators that the latter tend to form pools anyway, in order to decrease the variance on their revenue and profit from economies of scale. 
As an alternative, the system formalizes and facilitates the formation of these pools by allowing users to vote for candidates that they trust to represent them as validators, and then publicly electing a committee of $k$ validators. 
Networks that follow this approach include Polkadot, Cardano, EOS, Tezos, Cosmos, and Kusama, among many others. 
While similar in spirit, the validator election protocols in these networks vary in terms of design choices such as incentive structures, validator committee size $k$, and the election rule used. These choices are of the utmost importance as they affect the decentralization and security levels achieved by the network; yet, most projects lack any rigorous analysis behind their protocol design. An important contribution of this paper is precisely to provide such an analysis based on first principles.

We focus on Nominated Proof-of-Stake (NPoS), a variant of PoS introduced by Polkadot and Kusama~\cite{burdges2020overview}. In NPoS, any user is free to become a validator candidate, or a \emph{nominator} who provides an unranked list of any number of candidates that she trusts. At regular intervals of a few hours, a committee of $k$ validators --in the order of hundreds or thousands-- is elected according to the current nominators' votes. As a security measure, both validators and nominators have their tokens staked as collateral, so that if a validator ever shows negligent or adversarial behavior, all backing tokens are susceptible to being lost. Conversely, during normal execution the network provides economic rewards to all elected validators and their backing nominators on a pro-rata basis. Nominators are thus indirect participants in the consensus protocol with an economic incentive to follow the performance of validators and support only the most capable and trustworthy candidates. For the sake of simplicity, in what follows we consider a model where only nominators have staked tokens, not candidates, and we equate their stake amount to their voting strength. This leads to a vote-weighted, approval-based committee election problem. As mentioned before, our two goals behind this problem are proportionality and security. We formalize each of these goals next. 

\emph{Proportionality.} We aim to guarantee that nominators are not \emph{underrepresented} relative to their stake by the elected validators. We highlight that diverse preferences and factions may naturally arise among nominators for reasons that range from economically and technically motivated to political, geographical, etc., and that preserving this diversity among the validators helps ensure that the blockchain network stays decentralized. Electoral system designs that achieve some version of proportional representation have been present in the literature of social choice for a very long time. Of special note is the work of Scandinavian mathematicians Edvard Phragm\'{e}n and Thorvald Thiele in the late nineteenth century \cite{phragmen1894methode, phragmen1895proportionella, phragmen1896theorie, phragmen1899till, thiele1895om, janson2016phragmen}. 
Several axioms have been recently proposed to define the property mathematically -- we mention the most relevant ones. 
\emph{Justified representation} (JR)~\cite{aziz2017justified} states that if a group of voters is cohesive enough in terms of candidate preferences and has a large enough aggregate vote strength, then it has a justified claim to be represented by a member of the committee.
\emph{Proportional justified representation} (PJR)~\cite{sanchez2017proportional} says that such a group deserves not just one but a minimum number of representatives according to its vote strength, where a committee member is said to represent the group as long as it represents any voter in it.
Finally, \emph{extended justified representation} (EJR)~\cite{aziz2017justified} strengthens this last condition and requires not only that the group have enough representatives collectively, but some voter in it must have enough representatives individually.
It is known that EJR implies PJR and PJR implies JR, but converse implications are not true~\cite{sanchez2017proportional}. %
For each of these properties, a committee voting rule is said to satisfy said property if its output committee always satisfies it for any input instance. 
While the most common voting rules usually achieve JR, they fail the stronger properties of PJR and EJR, and up to recently there were no known efficient voting rules that satisfy the latter two. 
For instance, the \emph{proportional approval voting} (PAV) method \cite{thiele1895om, janson2016phragmen} proposed by Thiele satisfies EJR but is NP-hard to compute, while efficient heuristics based on it, such as reweighted approval voting, fail PJR \cite{aziz2014computational, skowron2016finding, aziz2017justified}. 
Only very recently have efficient algorithms that achieve PJR or EJR finally been proposed \cite{brill2017phragmen, sanchez2016maximin, aziz2018complexity, peters2019proportionality}. 

Among these axioms, \textbf{we set to achieve PJR}, defined formally in Section~\ref{s:prel}, for two reasons. 
First, because it is more \emph{Sybil resistant}~\cite{douceur2002sybil} than JR, meaning that in our blockchain application a strategic voter may be incentivized to assume several nominator identities in the network under JR, but not under PJR. 
Second, because PJR seems to be most compatible with our security objective, as we argue below. Indeed, as argued in~\cite{peters2019proportionality} and \cite{lackner2020approval}, the PJR and EJR axioms correspond to different notions of proportionality: while EJR is primarily concerned with the general welfare or satisfaction of the voters, PJR considers proportionality of the voters' decision power, and our security objective aligns best with the latter notion.

\emph{Security.} 
As is the case in any PoS-based blockchain network, under NPoS the basic security assumption is that most of the tokens are held by actors who behave honestly or rationally. Under this assumption, we consider a scenario where an adversary with a limited token budget attempts to carry out an attack on the network. Depending on the attack, it will require control of some minimum number of validators to succeed, so the adversary first needs to procure itself said number of representatives in the elected committee, and it may recur to strategic voting to achieve this. Therefore, the security level corresponds to how difficult it is for a voter or group of voters with limited aggregate voting strength to gain \emph{overrepresentation} in the elected committee. 

Further formalizing our election problem, we consider finite sets $N$ and $C$ of voters and candidates respectively, where every voter $n\in N$ provides a list $C_n\subseteq C$ of approved candidates and has a vote strength $s_n$. 
%There is also a target number $1\leq k< |C|$ of candidates to elect.
Suppose we want to make it as difficult as possible for an adversary to gain a certain threshold $1\leq r\leq k$ of representatives within the $k$-validator committee. 
Then, our goal would be to elect a committee $A\subseteq C$ that maximizes 
$$\min_{A'\subseteq A, |A'|=r} \sum_{n\in N: \ C_n\cap A'\neq \emptyset} s_n.$$ 

For any subset $A'\subseteq A$ of $r$ seats in committee $A$, the quantity above is the total vote strength that is backing any seat in $A'$, with no vote being double counted. In our blockchain application, this quantity also corresponds to the total collateral susceptible to being lost if $A'$ carries on an attack; hence, maximizing this amount not only makes it difficult for the adversary to gain enough representatives, but also costly to carry the attack if it does. Of course, we remark that on top of the potential collateral loss resulting from an attack, rational validators should consider the potential loss of reputation, which translates to further loss of future payouts. We thus obtain a different optimization objective for each value of threshold $r$. 
If we are only concerned about a particular threshold $r$, then we can fix the corresponding objective. 
For example, for $r=1$, maximizing this objective is equivalent to the classical multiwinner approval voting: selecting the $k$ candidates $c\in C$ with highest total approval $\sum_{n\in N: \ c\in C_n} s_n$. 
Or, we could set $r=\lceil k/3\rceil$, which is the minimum threshold required to carry on a successful attack in classical Byzantine fault tolerant protocols~\cite{pease1980reaching}. 
However, different types of attacks require different thresholds, and some attacks succeed with higher probability with more attacking validators. Hence, a more pragmatic approach is to incorporate the threshold into the objective and maximize \emph{the least possible cost per seat over all thresholds}, i.e.,  
\begin{align}\label{eq:security}
    \text{Maximize } \min_{A'\subseteq A, A'\neq \emptyset} \quad \frac{1}{|A'|} \sum_{n\in N: \ C_n\cap A' \neq \emptyset} s_n, \quad \text{over all committees $A\subseteq C$ with $|A|=k$}.
\end{align}

We establish in Lemma~\ref{lem:equivalence} that this objective is equivalent to the \textbf{maximin support objective}, recently introduced by Sánchez-Fernández et al.~\cite{sanchez2016maximin}, and which we thus set to optimize. 
We define it formally in Section~\ref{s:prel}.
%To define this last objective, which we do formally in Section~\ref{s:prel}, one needs the election rule to establish not only a winning committee $A\subseteq C$, but also a \emph{vote distribution}; that is, a fractional distribution of each voter $n$'s vote strength $s_n$ among her approved committee members in $C_n\cap A$.%
%\footnote{This is called a \emph{support distribution function} in~\cite{sanchez2016maximin}, and is related to the notion of a \emph{price system} in~\cite{peters2019proportionality}.} 
%For instance, for voter $n$ the election rule may assign a third of $s_n$ to $c_1$ and two thirds of $s_n$ to $c_2$, where $c_1, c_2\in C_n\cap A$. 
%The objective is then to maximize, over all possible committees and distributions, the least amount of vote assigned to any committee member. 
%We observe here that unlike most other applications of multiwinner elections, in NPoS there is practical utility in computing a vote distribution from nominators to the elected validators: by reversing its sense, it establishes the exact way in which the validators' payouts or penalties must be distributed back to the nominators.
The authors in~\cite{sanchez2016maximin} remark that in its exact version, maximin support is equivalent to another objective, $\maxphragmen$, devised by Phragm\'{e}n and recently analyzed in~\cite{brill2017phragmen}, and in this last paper it is shown that $\maxphragmen$ is NP-hard and incompatible with EJR. 
Thus, the same hardness and incompatibility with EJR holds true for our security objective. 
%To the best of our knowledge, the approximability of maximin support has not previously been studied.

\vspace{5mm}
\textbf{Our contribution.}
Our analysis of security of the validator election protocol leads us to pursue the maximin support objective, which fights overrepresentation. Conversely, we equate our proportionality goal with the PJR property, which fights underrepresentation. We show that these two goals complement each other well, and prove the existence of efficient election rules that achieve guarantees for both of them. 

\begin{theorem}\label{thm:intro1}
There is an efficient election rule for approval-based committee elections that simultaneously achieves the PJR property and a 3.15-factor approximation guarantee for the maximin support objective.
\end{theorem}

Our proposed election rule is inspired in the $\phragmen$ method~\cite{brill2017phragmen}, and to the best of our knowledge we present the first analysis of approximability for a Phragm\'{e}n objective. 
In contrast, several approximation algorithms for Thiele objectives have been proposed; see~\cite{lackner2020approval} for a survey. To complement this result, we also prove that a constant-factor approximation is theoretically best possible for the maximin support objective. 
%
Next comes the question of applicability: as we previously mentioned, the blockchain architecture adds very stringent time constraints to computations. However, if the output can be \emph{verified} much faster than it can be obtained from scratch, then the computation can be implemented as a verifiable computing scheme. This is the case for our election rule.

\begin{theorem}\label{thm:intro2}
There is a linear-time test that takes as input an election instance and an arbitrary solution to it, such that if the test passes then the input solution satisfies the PJR property and a 3.15-factor approximation guarantee for the maximin support objective. 
Moreover, the output of the election rule mentioned in Theorem~\ref{thm:intro1} always passes this test.
\end{theorem}

We remark that a solution passing said test is a sufficient but not a necessary condition for it to have the properties above, hence the fact that the output of our election rule always passes the test is not straightforward.
In the context of our blockchain application, this result enables the implementation of a fast validator election protocol with strong theoretical guarantees on security and proportionality. 
We provide details of such an implementation over the Polkadot network in Section~\ref{s:objectives}.
%
Finally, we derive from the new election rule a post-computation which, when paired with any approximation algorithm for the maximin support problem, makes it also satisfy the PJR property in a black-box manner.

\begin{theorem}\label{thm:intro3}
There is an efficient computation that takes as input an election instance and an arbitrary solution to it, and outputs a new solution which a) is no worse than the input solution in terms of the maximin support objective, b) satisfies the PJR property, and in particular c) can be efficiently tested to satisfy the PJR property.
\end{theorem}

%This result shows that the PJR property is strongly compatible with the maximin support objective, and can be easily added to future approximation algorithms that may be developed for this objective.

\vspace{5mm}
\textbf{Organization of the paper and technical overview.}
In Section~\ref{s:prel} we formalize our multiwinner election problem and its objectives and provide all the required technical definitions. Then, in Section~\ref{s:complexity} we present a thorough analysis of the complexity of the maximin support objective, where we exhibit constant-factor approximation algorithms for it, as well as prove a hardness result showing that a constant-factor guarantee is best possible. 
We also compare the performance of several common election rules with respect to this objective, and show that in fact most of them do not achieve constant-factor approximations for it.
In Section~\ref{s:heuristic} we propose a new heuristic, $\phragmms$, inspired in $\phragmen$~\cite{brill2017phragmen} but allowing for a more robust analysis and better guarantees than the latter both in terms of the PJR property and the maximin support objective, and we use it to prove Theorem~\ref{thm:intro1}. 

In these sections we formalize the \emph{load balancing} technique used in $\phragmen$ in terms of network flow, give a precise definition of what a \emph{balanced solution} is, and provide an algorithm to compute one efficiently using notions of parametric flow. 
We then synthesize the strategies of different relevant heuristics in terms of how they compute or approximate balanced solutions, and use the flow decomposition theorem to establish approximation guarantees. 
Our comparison provides new tools to discern between election rules. For instance, the survey paper by Lackner and Skowron~\cite{lackner2020approval} mentions $\phragmen$ and $\MMS$~\cite{sanchez2016maximin} as two efficient rules that achieve the PJR property and leaves as an open question which of the two is preferable, whereas we show that the latter provides a constant-factor approximation guarantee for maximin support but the former does not. 
Furthermore, contrary to the common notion that the EJR property is categorically superior than PJR, we establish PJR as the better choice in terms of security.

In Section~\ref{s:local} we prove Theorems \ref{thm:intro2} and \ref{thm:intro3}, and explore how the PJR property and a constant-factor approximation guarantee for maximin support can be efficiently tested, even if the algorithm is privately executed by an untrusted party who only communicates the solution. 
To do so, we define a parametric version of the PJR property, and link it to a notion of local optimality for our new heuristic. Finally, in Section~\ref{s:objectives} we provide details on how our proposed voting rule has been implemented in the validator election protocol of Polkadot, as a verifiable computing scheme.
%We present some conclusion and open question in Section~\ref{s:conclusions}.
